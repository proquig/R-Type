      .          .           .               .        .               .
          .         .            .    .               .           .             
      .      .            .    .               .           .             .
    .      .__________        ___________                        .
      	    \______   \       \__    ___/__.__.______   ____  
  .   	     |       _/  ______ |    | <   |  |\____ \_/ __ \ 		.     .    
        .    |    |   \ /_____/ |    |  \___  ||  |_> >  ___/   .
    .        |____|_  /         |____|  / ____||   __/ \___  >
      	            \/                  \/     |__|        \/        .       .
   .               .           .             .
      .               .           .               .        .             .
          .         .            .    .               .           .             
   .      .    .        .               .           .             .
      .               .           .               .        .            
  .      .            .                 .                               
        .                   .               .         .             .    .
      .               .           .               .        .            

          .         .            .    .               .           .             
  .      .            .                 .                                  .
        .      .      .  _
  .               .     | \                    .            .          .
            .          =[_|H)--._____
     .                 =[+--,-------'     .   .       .          .          .
                 .      [|_/""
  .      .               .      .         .                .      .
      .         .                  .    .               .           .           
      .          .           .               .        .             .       .
          .         .            .    .               .           .             
      .      .            .    .               .           .             .
  .      .            .                         .                           
        .      .      .          .         .      .         .     
      .      .            .    .                       .           .         .   
      .      .            .                 .                                .
  .      .         .         .   . :::::+::::...      .          .         .
      .         .      .    ..::.:::+++++:::+++++:+::.    .     .
                         .:.  ..:+:..+|||+..::|+|+||++|:.             .     .
             .   .    :::....:::::::::++||||O||O#OO|OOO|+|:.    .
 .      .      .    .:..:..::+||OO#|#|OOO+|O||####OO###O+:+|+               .
                  .:...:+||O####O##||+|OO|||O#####O#O||OO|++||:     .    .
   .             ..::||+++|+++++|+::|+++++O#O|OO|||+++..:OOOOO|+  .         .
      .   .     +++||++:.:++:..+#|. ::::++|+++||++O##O+:.++|||#O+    .
 .           . ++++++++...:+:+:.:+: ::..+|OO++O|########|++++||##+            .
   .       .  :::+++|O+||+::++++:::+:::+++::+|+O###########OO|:+OO       .  .
      .       +:+++|OO+|||O:+:::::.. .||O#OOO||O||#@###@######:+|O|  .
  .          ::+:++|+|O+|||++|++|:::+O#######O######O@############O
           . ++++: .+OO###O++++++|OO++|O#@@@####@##################+         .
       .     ::::::::::::::::::::++|O+..+#|O@@@@#@###O|O#O##@#OO####     .
  .        . :. .:.:. .:.:.: +.::::::::  . +#:#@:#@@@#O||O#O@:###:#| .      .
  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 1] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

S̲t̲a̲t̲u̲s̲ ̲o̲f̲ ̲t̲h̲i̲s̲ ̲M̲e̲m̲o̲ ̲:̲

  This document specifies the R-Type standard protocol for the Epitech's
  groups participating the R-Type project at Epitech (2016-2017).
  Please referer to M. Lambert (lamber_o) of Guillaume Proquin (proqui_g) for
  any question aout this document. The distribution of this document is stictly
  reserved to Epitech's Members.

C̲o̲p̲y̲r̲i̲g̲h̲t̲ ̲N̲o̲t̲i̲c̲e̲ ̲:̲

  There is no currents Copyright for this project. This project is the
  intellectual property of the Epitech's members who are developping
  the software.

A̲b̲s̲t̲r̲a̲c̲t̲ ̲:̲

  R-Type (アール・タイプ Āru Taipu) is a side scrolling shoot-em-up arcade game
  produced by Irem in 1987. The player controls a space fighter named the R-9
  to defend humanity against a mysterious powerful alien life-form known as the
  "Bydo".
  The Epitech R-Type is a simple clone of the game. It is designed in C++ and
  can handle a multiplayer gameplay. The goal of this project is to do a clone
  of this well known arcade game. However, this clone will not be limited
  to the technical requierements of the year 1987.
  Such as the most of the multiplayer video-game available on the market, the
  project will be devided in two part. The first one is the Server which
  handle all the game sessions. The second part of the project is the client,
  which is designed to handle the actions between the server and the player
  in front of his computer.
  The software is organized so that there is no performance concerns.




















  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 2] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

T̲a̲b̲l̲e̲ ̲o̲f̲ ̲c̲o̲n̲t̲e̲n̲t̲s̲ ̲:̲ ̲

  1 - Introduction....................................................3
  1.1 Purpose.........................................................3
  1.2 Requierements...................................................3
  1.3 Terminology.....................................................4
  1.4 Overall Operation...............................................8
  2 - TCP.............................................................9
  2.1 Introduction....................................................9
  2.2 Purpose........................................................10
  2.3 Overall Operation..............................................10
  3 - UDP............................................................13
  3.1 Introduction...................................................13
  3.2 Format.........................................................13
  3.3 Fields.........................................................14
  3.4 User Interface.................................................14
  3.5 IP Interface...................................................15
  4 - Header.........................................................16
  4.1 Purpose........................................................16
  4.2 Organisation...................................................16
  4.3 Signification..................................................17
  5 - Data...........................................................18
  5.1 Purpose........................................................18
  5.2 OpCodes........................................................18
  5.3 Data format....................................................20






















  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 3] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

1̲ ̲-̲ ̲I̲n̲t̲r̲o̲d̲u̲c̲t̲i̲o̲n̲

1̲.̲1̲ ̲P̲u̲r̲p̲o̲s̲e̲

  In the third year of Epitech, some students take the Advanced/c++ module to
  have more knowledge of the C++ language. In order to archieve this goal a
  video-game project is proposed to the registered students. The "R-Type" is
  the name of the project. This video-game must be designed to able the
  communication different servers around the world. The communication protocol
  is here to guide any developpers who needs/wants to develop or modify, on
  their own a server or a client for the R-Type.

1̲.̲2̲ ̲R̲e̲q̲u̲i̲e̲r̲e̲m̲e̲n̲t̲s̲

  A̲b̲s̲t̲r̲a̲c̲t̲

    In many standards track documents several words are used to signify the
    requirements in the specification. These words are often capitalized.
    This document defines these words as they should be interpreted in this
    documentation. Authors who follow these guidelines should incorporate this
    phrase near the beginning of their document:

  The key words "M̲U̲S̲T̲", "M̲U̲S̲T̲ ̲N̲O̲T̲", "R̲E̲Q̲U̲I̲R̲E̲D̲", "S̲H̲A̲L̲L̲", "S̲H̲A̲L̲L̲ ̲N̲O̲T̲", "S̲H̲O̲U̲L̲D̲",
  "S̲H̲O̲U̲L̲D̲ ̲N̲O̲T̲", "R̲E̲C̲O̲M̲M̲E̲N̲D̲E̲D̲",  "M̲A̲Y̲", and "O̲P̲T̲I̲O̲N̲A̲L̲" in this document are to
  be interpreted as described just below.

  Note that the force of these words is modified by the requirement level of
  the document in which they are used.

  "M̲U̲S̲T̲" :  This word, or the terms "R̲E̲Q̲U̲I̲R̲E̲D̲" or "S̲H̲A̲L̲L̲", mean that the
  definition is an absolute requirement of the specification.

  "M̲U̲S̲T̲ ̲N̲O̲T̲" :  This phrase, or the phrase "S̲H̲A̲L̲L̲ ̲N̲O̲T̲", mean that the definition
  is an absolute prohibition of the specification.

  "S̲H̲O̲U̲L̲D̲" :  This word, or the adjective "R̲E̲C̲O̲M̲M̲E̲N̲D̲E̲D̲", mean that there may
  exist valid reasons in particular circumstances to ignore a particular item,
  but the full implications must be understood and carefully weighed before
  choosing a different course.

  "S̲H̲O̲U̲L̲D̲ ̲N̲O̲T̲" :  This phrase, or the phrase "N̲O̲T̲ ̲R̲E̲C̲O̲M̲M̲E̲N̲D̲E̲D̲" mean that
  there may exist valid reasons in particular circumstances when the particular
  behavior is acceptable or even useful, but the full implications should be
  understood and the case carefully weighed before implementing any behavior
  described with this label.





  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 4] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

  "M̲A̲Y̲" :   This word, or the adjective "O̲P̲T̲I̲O̲N̲A̲L̲", mean that an item is
  truly optional. One vendor may choose to include the item because a
  particular marketplace requires it or because the vendor feels that it
  enhances the product while another vendor may omit the same item. An
  implementation which does not include a particular option M̲U̲S̲T̲ be prepared
  to interoperate with another implementation which does include the option,
  though perhaps with reduced functionality. In the same vein an
  implementation which does include a particular option M̲U̲S̲T̲ be prepared to
  interoperate with another implementation which does not include the option
  (except, of course, for the feature the option provides.)
  
  G̲u̲i̲d̲a̲n̲c̲e̲ ̲i̲n̲ ̲t̲h̲e̲ ̲u̲s̲e̲ ̲o̲f̲ ̲t̲h̲e̲s̲e̲ ̲I̲m̲p̲e̲r̲a̲t̲i̲v̲e̲s̲

    Imperatives of the type defined in this memo must be used with care and
    sparingly. In particular, they M̲U̲S̲T̲ only be used where it is actually
    required for interoperation or to limit behavior which has potential for
    causing harm (limiting retransmisssions) For example, they must not be
    used to try to impose a particular method on implementors where the method
    is not required for interoperability.

  S̲e̲c̲u̲r̲i̲t̲y̲ ̲C̲o̲n̲s̲i̲d̲e̲r̲a̲t̲i̲o̲n̲s̲

    These terms are frequently used to specify behavior with security
    implications. The effects on security of not implementing a M̲U̲S̲T̲ or
    S̲H̲O̲U̲L̲D̲, or doing something the specification says M̲U̲S̲T̲ NOT or S̲H̲O̲U̲L̲D̲ N̲O̲T̲
    be done may be very subtle. Document authors should take the time to
    elaborate the security implications of not following recommendations or
    requirements as most implementors will not have had the benefit of the
    experience and discussion that produced the specification.

1̲.̲3̲ ̲T̲e̲r̲m̲i̲n̲o̲l̲o̲g̲y̲

  This specification uses a number of terms to refer to the roles played by
  participants in, and objects of, the Socket communication.

  C̲o̲n̲n̲e̲c̲t̲i̲o̲n̲
    A transport layer virtual circuit established between two programs for
    the purpose of communication.

  M̲e̲s̲s̲a̲g̲e̲
    The basic unit of Socket communication, consisting of a structured
    sequence of octets matching the syntax defined in section 3 and
    transmitted via the connection.

  R̲e̲q̲u̲e̲s̲t̲
    An Socket request message, as defined in section 3.




  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 5] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/
  
  R̲e̲s̲p̲o̲n̲s̲e̲
    An Socket response message, as defined in section 3.
    
  R̲e̲s̲o̲u̲r̲c̲e̲
    A dll/library object or service that can be identified by a name and a
    path, as defined in section 1.4. Resources may be available in multiple
    representations (multiple functions, developpement languages, size, and
    utilities) or vary in other ways.

  E̲n̲t̲i̲t̲y̲
    The information transferred as the payload of a request or response. An
    entity consists of metainformation in the form of entity-header fields
    and content in the form of an entity-body, as described in section 3.

  R̲e̲p̲r̲e̲s̲e̲n̲t̲a̲t̲i̲o̲n̲
    An entity included with a response that is subject to content
    negotiation, as described in section 4. There may exist multiple
    representations associated with a particular response status. 

  C̲o̲n̲t̲e̲n̲t̲ ̲n̲e̲g̲o̲t̲i̲a̲t̲i̲o̲n̲
    The mechanism for selecting the appropriate representation when
    servicing a request, as described in section 12. The representation of
    entities in any response can be negotiated (including error responses).

  V̲a̲r̲i̲a̲n̲t̲
    A resource may have one, or more than one, representation(s) associated
    with it at any given instant. Each of these representations is termed a
    `varriant'. Use of the term `variant' does not necessarily imply that
    the resource is subject to content negotiation.

  C̲l̲i̲e̲n̲t̲
    A program that establishes connections for the purpose of sending
    requests.

  U̲s̲e̲r̲ ̲a̲g̲e̲n̲t̲
    The client which initiates a request. These are often browsers,
    editors, spiders (web-traversing robots), or other end user tools.

  S̲e̲r̲v̲e̲r̲
    An application program that accepts connections in order to service
    requests by sending back responses. Any given program may be capable of
    being both a client and a server; our use of these terms refers only to
    the role being performed by the program for a particular connection,
    rather than to the program's capabilities in general. Likewise, any
    server may act as an origin server, proxy, gateway, or tunnel,
    switching behavior based on the nature of each request.




  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 6] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

  O̲r̲i̲g̲i̲n̲ ̲s̲e̲r̲v̲e̲r̲
    The server on which a given resource resides or is to be created.

  P̲r̲o̲x̲y̲
    An intermediary program which acts as both a server and a client for the
    purpose of making requests on behalf of other clients. Requests are
    serviced internally or by passing them on, with possible translation, to
    other servers. A proxy M̲U̲S̲T̲ implement both the client and server
    requirements of this specification. A "transparent proxy" is a proxy that
    does not modify the request or response beyond what is required for proxy
    authentication and identification. A "non-transparent proxy" is a proxy
    that modifies the request or response in order to provide some added
    service to the user agent, such as group annotation services, media type
    transformation, protocol reduction, or anonymity filtering. Except where
    either transparent or non-transparent behavior is explicitlystated, the
    proxy requirements apply to both types of proxies.

  G̲a̲t̲e̲w̲a̲y̲
    A server which acts as an intermediary for some other server. Unlike a 
    proxy, a gateway receives requests as if it were the origin server for
    the requested resource; the requesting client may not be aware that it is
    communicating with a gateway.

  T̲u̲n̲n̲e̲l̲
    An intermediary program which is acting as a blind relay between two
    connections. Once active, a tunnel is not considered a party to the Socket
    communication, though the tunnel may have been initiated by an Socket
    request. The tunnel ceases to exist when both ends of the relayed
    connections are closed.

  C̲a̲c̲h̲e̲
    A program's local store of response messages and the subsystem that 
    controls its message storage, retrieval, and deletion. A cache stores
    cacheable responses in order to reduce the response time and network
    bandwidth consumption on future, equivalent requests. Any client or
    server may include a cache, though a cache cannot be used by a server
    that is acting as a tunnel.

  C̲a̲c̲h̲e̲a̲b̲l̲e̲
    A response is cacheable if a cache is allowed to store a copy of the
    response message for use in answering subsequent requests. The rules for
    determining the cacheability of Socket responses are defined in section 4.
    Even if a resource is cacheable, there may be additional constraints on
    whether a cache can use the cached copy for a particular request.




 

  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 7] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

  F̲i̲r̲s̲t̲-̲h̲a̲n̲d̲
    A response is first-hand if it comes directly and without unnecessary
    delay from the origin server, perhaps via one or more proxies. A response
    is also first-hand if its validity has just been checked directly with
    the origin server.

  E̲x̲p̲l̲i̲c̲i̲t̲ ̲e̲x̲p̲i̲r̲a̲t̲i̲o̲n̲ ̲t̲i̲m̲e̲
    The time at which the origin server intends that an entity should no
    longer be returned by a cache without further validation.

  H̲e̲u̲r̲i̲s̲t̲i̲c̲ ̲e̲x̲p̲i̲r̲a̲t̲i̲o̲n̲ ̲t̲i̲m̲e̲
    An expiration time assigned by a cache when no explicit expiration time
    is available.

  A̲g̲e̲
    The age of a response is the time since it was sent by, or successfully
    validated with, the origin server.

  F̲r̲e̲s̲h̲n̲e̲s̲s̲ ̲l̲i̲f̲e̲t̲i̲m̲e̲
    The length of time between the generation of a response and its expiration
    time.

  F̲r̲e̲s̲h̲
    A response is fresh if its age has not yet exceeded its freshness
    lifetime.

  S̲t̲a̲l̲e̲
    A response is stale if its age has passed its freshness
    lifetime.

  S̲e̲m̲a̲n̲t̲i̲c̲a̲l̲l̲y̲ ̲t̲r̲a̲n̲s̲p̲a̲r̲e̲n̲t̲
    A cache behaves in a "semantically transparent" manner,
    with respect to a particular response, when its use affects
    neither the requesting client nor the origin server, except
    to improve performance. When a cache is semantically
    transparent, the client receives exactly the same response
    (except for the validator element) that it would have received
    had its request been handled directly by the origin server.

  V̲a̲l̲i̲d̲a̲t̲o̲r̲
          A protocol element (an entity tag or a Last-Modified
    time) that is used to find out whether a cache entry is an
    equivalent copy of an entity.

  U̲p̲s̲t̲r̲e̲a̲m̲/̲D̲o̲w̲n̲s̲t̲r̲e̲a̲m̲
    Upstream and downstream describe the flow of a message: all
    messages flow from upstream to downstream.



  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 8] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

  I̲n̲b̲o̲u̲n̲d̲/̲O̲u̲t̲b̲o̲u̲n̲d̲
    Inbound and outbound refer to the request and response paths
    for messages: "inbound" means "traveling toward the origin
    server", and "outbound" means "traveling toward the user
    agent"

1̲.̲4̲ ̲O̲v̲e̲r̲a̲l̲l̲ ̲O̲p̲e̲r̲a̲t̲i̲o̲n̲

  The R-Type protocol is a request/response protocol. A client sends
  a request to the server in the form of a request method, followed by
  a MIME-like message containing request modifiers, client information,
  and possible body content over a connection with a server. The server
  responds with a status line, including the message's protocol version
  and a success or error code, followed by a MIME-like message
  containing server information, entity metainformation, and possible
  entity-body content.

  Most Socket communication is initiated by a user agent and consists of
    a request to be applied to a resource on some origin server. In the
    simplest case, this may be accomplished via a single connection (v)
  between the user agent (UA) and the origin server (O).


  request chain → 
    UA -------------------v------------------- O
                   ← response chain

  A more complicated situation occurs when one or more intermediaries
  are present in the request/response chain. There are three common
  forms of intermediary: proxy, gateway, and tunnel. A proxy is a
  forwarding agent, receiving requests for a IP in its absolute form,
  rewriting all or part of the message, and forwarding the reformatted
  request toward the server identified by the URI. A gateway is a
  receiving agent, acting as a layer above some other server(s) and, if
  necessary, translating the requests to the underlying server's
  protocol. A tunnel acts as a relay point between two connections
  without changing the messages; tunnels are used when the
  communication needs to pass through an intermediary (such as a
  firewall) even when the intermediary cannot understand the contents
  of the messages.


  request chain → 
    UA -----v----- A -----v----- B -----v----- C -----v----- O
                   ← response chain


  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                        [Page 9] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

  The figure above shows three intermediaries (A, B, and C) between the
  user agent and origin server. A request or response message that
  travels the whole chain will pass through four separate connections.
  This distinction is important because some Socket communication
  options may apply only to the connection with the nearest, non-tunnel
  neighbor, only to the end-points of the chain, or to all connections
  along the chain. Although the diagram is linear, each participant may
  be engaged in multiple, simultaneous communications. For example, B
  may be receiving requests from many clients other than A, and/or
  forwarding requests to servers other than C, at the same time that it
  is handling A's request.

  Any party to the communication which is not acting as a tunnel may
  employ an internal cache for handling requests. The effect of a cache
  is that the request/response chain is shortened if one of the
  participants along the chain has a cached response applicable to that
  request. The following illustrates the resulting chain if B has a
  cached copy of an earlier response from O (via C) for a request which
  has not been cached by UA or A.

  request chain → 
    UA -----v----- A -----v----- B - - - - - - C - - - - - - O
                   ← response chain

  Not all responses are usefully cacheable, and some requests may
  contain modifiers which place special requirements on cache behavior.
  Socket requirements for cache behavior and cacheable responses are
  defined in section TOFIX.

  Socket communication usually takes place over TCP/IP connections but
  can also use UDP connections. There is no prefered ports for Socket
  so any port can be used. This does not preclude Socket from being
  implemented on top of any other protocol on the Internet, or on other
  networks. Socket only presumes a reliable transport; any protocol
  that provides such guarantees can be used; the mapping of the Socket
  request and response structures onto the transport data units of the
  protocol in question is outside the scope of this specification.

2̲ ̲-̲ ̲T̲C̲P̲

  2̲.̲1̲ ̲-̲ ̲I̲n̲t̲r̲o̲d̲u̲c̲t̲i̲o̲n̲

    The Transmission Control Protocol (TCP) is intended for use as a highly
    reliable host-to-host protocol between hosts in packet-switched computer 
    communication networks, and in interconnected systems of such networks.


  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 10] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

    The TCP is intended to provide a reliable process-to-process communication
    service in a multinetwork environment. The TCP is intended to be a
    host-to-host protocol in common use in multiple networks.

  2̲.̲2̲ ̲-̲ ̲P̲u̲r̲p̲o̲s̲e̲ ̲:̲

    The internetwork environment consists of hosts connected to networks which
    are in turn interconnected via gateways. It is assumed here that the
    networks may be either local networks or large networks, but in any case
    are based on packet switching technology. The active agents that produce
    and consume messages are processes.  Various levels of protocols in the
    networks, the gateways, and the hosts support an interprocess
    communication system that provides two-way data flow on logical
    connections between process ports.

    The term packet is used generically here to mean the data of one
    transaction between a host and its network. The format of data blocks
    exchanged within the a network will generally not be of concern to us.

    Hosts are computers attached to a network, and from the communication
    network's point of view, are the sources and destinations of packets.
    Processes are viewed as the active elements in host computers (in
    accordance with the fairly common definition of a process as a program
    in execution). Even terminals and files or other I/O devices are viewed
    as communicating with each other through the use of processes. Thus,
    all communication is viewed as inter-process communication.

    Since a process may need to distinguish among several communication
    streams between itself and another process (or processes), we imagine
    that each process may have a number of ports through which it communicates
    with the ports of other processes.
    
    TCP is a really reliable way to communicate beetween twoo computer/server.
    For the quality TCP will be used in the R-Type project.

  2̲.̲3̲ ̲-̲ ̲O̲v̲e̲r̲a̲l̲l̲ ̲O̲p̲e̲r̲a̲t̲i̲o̲n̲ ̲:̲

    As noted above, the primary purpose of the TCP is to provide reliable,
    securable logical circuit or connection service between pairs of processes.
    To provide this service on top of a less reliable internet communication
    system requires facilities in the following areas:

    Basic Data Transfer
    Reliability
    Flow Control
    Connections
    Precedence and Security
    Model of Operation



  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 11] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

    The basic operation of the TCP in each of these areas is described in the
    following paragraphs.

    Basic Data Transfer:

    The TCP is able to transfer a continuous stream of octets in each
    direction between its users by packaging some number of octets into
    segments for transmission through the internet system. In general,
    the TCPs decide when to block and forward data at their own
    convenience.

    Sometimes users need to be sure that all the data they have
    submitted to the TCP has been transmitted. For this purpose a push
    function is defined. To assure that data submitted to a TCP is
    actually transmitted the sending user indicates that it should be
    pushed through to the receiving user. A push causes the TCPs to
    promptly forward and deliver data up to that point to the receiver.
    The exact push point might not be visible to the receiving user and
    the push function does not supply a record boundary marker.

    Reliability:

    The TCP must recover from data that is damaged, lost, duplicated, or
    delivered out of order by the internet communication system. This
    is achieved by assigning a sequence number to each octet
    transmitted, and requiring a positive acknowledgment (ACK) from the
    receiving TCP. If the ACK is not received within a timeout
    interval, the data is retransmitted. At the receiver, the sequence
    numbers are used to correctly order segments that may be received
    out of order and to eliminate duplicates. Damage is handled by
    adding a checksum to each segment transmitted, checking it at the
    receiver, and discarding damaged segments.

    As long as the TCPs continue to function properly and the internet
    system does not become completely partitioned, no transmission
    errors will affect the correct delivery of data. TCP recovers from
    internet communication system errors.

    Flow Control:

    TCP provides a means for the receiver to govern the amount of data
    sent by the sender. This is achieved by returning a "window" with
    every ACK indicating a range of acceptable sequence numbers beyond
    the last segment successfully received.  The window indicates an
    allowed number of octets that the sender may transmit before
    receiving further permission.





  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 12] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

    Connections:

    The reliability and flow control mechanisms described above require
    that TCPs initialize and maintain certain status information for
    each data stream. The combination of this information, including
    sockets, sequence numbers, and window sizes, is called a connection.
    Each connection is uniquely specified by a pair of sockets
    identifying its two sides.

    When two processes wish to communicate, their TCP's must first
    establish a connection (initialize the status information on each
    side). When their communication is complete, the connection is
    terminated or closed to free the resources for other uses.

    Since connections must be established between unreliable hosts and
    over the unreliable internet communication system, a handshake
    mechanism with clock-based sequence numbers is used to avoid
    erroneous initialization of connections.

    Precedence and Security:

    The users of TCP may indicate the security and precedence of their
    communication. Provision is made for default values to be used when
    these features are not needed.

    Model of Operation:

    Processes transmit data by calling on the TCP and passing buffers of
    data as arguments. The TCP packages the data from these buffers into
    segments and calls on the internet module to transmit each segment to
    the destination TCP. The receiving TCP places the data from a segment
    into the receiving user's buffer and notifies the receiving user.  The
    TCPs include control information in the segments which they use to ensure
    reliable ordered data transmission.

    The model of internet communication is that there is an internet protocol
    module associated with each TCP which provides an interface to the local
    network. This internet module packages TCP segments inside internet
    datagrams and routes these datagrams to a destination internet module or
    intermediate gateway. To transmit the datagram through the local network,
    it is embedded in a local network packet.

    The packet switches may perform further packaging, fragmentation, or other
    operations to achieve the delivery of the local packet to the destination
    internet module.

    At a gateway between networks, the internet datagram is "unwrapped" from
    its local packet and examined to determine through which network the
    internet datagram should travel next. The internet datagram is then
    "wrapped" in a local packet suitable to the next network and routed to
    the next gateway, or to the final destination.

  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 13] |
|                                   ~R-Type~                                  |
|   RFC 1                                                        Novembre2016 |
 \___________________________________________________________________________/

    A gateway is permitted to break up an internet datagram into smaller
    internet datagram fragments if this is necessary for transmission
    through the next network. To do this, the gateway produces a set of
    internet datagrams; each carrying a fragment. Fragments may be further
    broken into smaller fragments at subsequent gateways. The internet
    datagram fragment format is designed so that the destination internet
    module can reassemble fragments into internet datagrams.

    A destination internet module unwraps the segment from the datagram (after
    reassembling the datagram, if necessary) and passes it to the destination
    TCP.

    This simple model of the operation glosses over many details. One
    important feature is the type of service. This provides information to
    the gateway (or internet module) to guide it in selecting the service
    parameters to be used in traversing the next network.
    Included in the type of service information is the precedence of the
    datagram. Datagrams may also carry security information to permit host
    and gateways that operate in multilevel secure environments to properly
    segregate datagrams for security considerations.

  3̲ ̲-̲ ̲U̲D̲P̲ ̲:̲

    3̲.̲1̲ ̲-̲ ̲I̲n̲t̲r̲o̲d̲u̲c̲t̲i̲o̲n̲

      This User Datagram Protocol (UDP) is defined to make available a datagram
      mode of packet-switched computer communication in the environment of an
      interconnected set of computer networks. This protocol assumes that the
      Internet Protocol (IP) is used as the underlying protocol.

      This protocol provides a procedure for application programs to send
      messages to other programs with a minimum of protocol mechanism. The
      protocol is transaction oriented, and delivery and duplicate protection
      are not guaranteed. Applications requiring ordered reliable delivery of
      streams of data should use the Transmission Control Protocol (TCP).


    3̲.̲2̲ ̲-̲ ̲F̲o̲r̲m̲a̲t̲

      0      7 8     15 16    23 24    31
      +--------+--------+--------+--------+
      |     Source      |   Destination   |
      |      Port       |      Port       |
      +--------+--------+--------+--------+
      |                 |                 |
      |     Length      |    Checksum     |
      +--------+--------+--------+--------+
      |
      |          data octets ...
      +---------------- ...

      User Datagram Header Format


  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 14] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

    3̲.̲3̲ ̲-̲ ̲F̲i̲e̲l̲d̲s̲

      Source Port is an optional field, when meaningful, it indicates the port
      of the sending process, and may be assumed to be the port to which a
      reply should be addressed in the absence of any other information. If
      not used, a value of zero is inserted.

      Destination Port has a meaning within the context of a particular
      internet destination address.

      Length is the length in octets of this user datagram including this
      header and the data. (This means the minimum value of the length is
      eight.)

      Checksum is the 16-bit one's complement of the one's complement sum of a
      pseudo header of information from the IP header, the UDP header, and the
      data, padded with zero octets at the end (if necessary) to make a
      multiple of two octets.

      The pseudo header conceptually prefixed to the UDP header contains the
      source address, the destination address, the protocol, and the UDP
      length. This information gives protection against misrouted datagrams.
      This checksum procedure is the same as is used in TCP.

        0      7 8     15 16    23 24    31
        +--------+--------+--------+--------+
        |          source address           |
        +--------+--------+--------+--------+
        |        destination address        |
        +--------+--------+--------+--------+
        |  zero  |protocol|   UDP length    |
        +--------+--------+--------+--------+

      If the computed checksum is zero, it is transmitted as all ones (the
      equivalent in one's complement arithmetic). An all zero transmitted
      checksum value means that the transmitter generated no checksum (for
      debugging or for higher level protocols that don't care).

    3̲.̲4̲ ̲-̲ ̲U̲s̲e̲r̲ ̲I̲n̲t̲e̲r̲f̲a̲c̲e̲

      A user interface should allow the creation of new receive ports, receive
      operations on the receive ports that return the data octets and an
      indication of source port and source address, and an operationthat allows
      a datagram to be sent, specifying the data, source and destination ports
      and addresses to be sent.



  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 15] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

    3̲.̲5̲ ̲-̲ ̲I̲P̲ ̲I̲n̲t̲e̲r̲f̲a̲c̲e̲

      The UDP module must be able to determine the source and destination
      internet addresses and the protocol field from the internet header. One
      possible UDP/IP interface would return the whole internet datagram
      including all of the internet header in response to a receive operation.
      Such an interface would also allow the UDP to pass a full internet
      datagram complete with header to the IP to send. The IP would verify
      certain fields for consistency and compute the internet header checksum.






































  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 16] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

4̲ ̲-̲ ̲H̲e̲a̲d̲e̲r̲

  4̲.̲1̲ ̲-̲ ̲P̲u̲r̲p̲o̲s̲e̲
  

    The header refers to supplemental data placed at the beginning of a
    block of data being stored or transmitted. In data transmission, the
    data following the header is called the body.
    The header of the message is a structure sent with the data in order
    to organize and recognize if the socket message is legit. This
    structure contains different datas that allow the server and the client
    to give and understand different order.

    This header is critical MUST be present in each packet in order that
    the server and the clients can communicate the right way.

    Any packet sent without this header will be refused on the server
    or the client side.
    The different fields of this header are defined in the section 4.2.

  4̲.̲2̲ ̲-̲ ̲O̲r̲g̲a̲n̲i̲s̲a̲t̲i̲o̲n̲


    The client and the server MUST share the same game header protocol.
    If a client DON'T fill this header correctly, the server WILL refuse
    the connection and will not take in account the packet.

    This protocol will use some techniques to prevent lag and packet loss.

    We have automatic reemission of the packets if not marked as
    acknowledged. (see section 5.2)

    The header for game client protocol is defined like this:


  +======+===============+===============+===============+===============+
  | Byte |       1       |       2       |       3       |       4       |
  |------|---------------|---------------|---------------|---------------|
  | Bit  |   0  ...  7   |   8  ...  15  |  16  ...  23  |  24  ...  31  |
  |------|---------------|---------------|---------------|---------------|
  |      |     Magic     |    Game ID    |   Packet ID   |    OpCode     |
  |      |---------------+---------------+---------------+---------------|
  |      |                             Size                              |
  |      |---------------------------------------------------------------|
  |      |                             Timer                             |
  |      |---------------------------------------------------------------|
  |      |                             Data                              |
  +======+===============================================================+


  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 17] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


  4̲.̲3̲ ̲-̲ ̲S̲i̲g̲n̲i̲f̲i̲c̲a̲t̲i̲o̲n̲

    The "Magic" is a unique id, permitting a small verifiction that the
    client correctly send a packet to the server, so they have the same 
    communication protocol. The client MUST have the same magic number as
    the server as it WILL be checked on the server side.
    If it is not the case, the server WILL close the connection with the
    client.
    Magic ID MUST be filled in an unsigned char, i.e. : 42. (between 0 and
    255)

    The "Game ID" is the ID of the game where the client is.
    This id MUST be unique to separate games on the server.
    If the server receives a wrong game id by a client, the connection between
    them will be closed.
    It must be stored in an unsigned char. i.e. : 2. (between 0 and 255)

    The "Packet ID" defines the Packet ID. Like other previous ids, it MUST
    be an unsigne char. (between 0 and 255)

    The "OpCode" specifies the form of data OR the packet's feature.
    It MUST be filled in an 8 bytes, a pair of 4 bits.
    (See section 5 for the data and section 5.2 for the opcode)

    The "Size" defines the size of the packet, the size is variable.
    It MUST be an unsigned int. If the size is incorrect the packet WILL NOT
    be processed.

    The "Timer" represents the timer, it describes the interval.
    It MUST be an unsigned int.

    The "Data" defines the data being sent. There are 4 forms of data.
    Data SHOULD be filled.
    See the section 5 for more informations.












  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 18] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/

5̲ ̲-̲ ̲D̲a̲t̲a̲

  5̲.̲1̲ ̲-̲ ̲P̲u̲r̲p̲o̲s̲e̲

    The "Data" defines the data filled right after the header in a packet.
    This "Data" can be sent by either the client or the server.

    This "Data" is decomposed in 4 forms, all representing events :

      - The "input data from client" which is sent when the player do an
        action with his keyboard like moving hi spaceship or shooting
        enemies.

      - The "game data from server" which represents an event on the server
        side, this data contains all Elements containing the map and the
        players elements.

      - The "player info", containing the characteristics of a player in the
        actual game, it contains its lives, his state (if he is dead or
        alive) and his score.

      - The "game element info" that contains the characteristics of an
      element of the map, like his position on the map and his speed.


    All these different kinds of data are identified with an OpCode
    (see section 4.2) and are explained in more details in the sections
    5.2 and 5.3.


  5̲.̲2̲ ̲-̲ ̲O̲p̲C̲o̲d̲e̲s̲

    The OpCode, defined in the header, permits a better communication
    between the client and the server, it prevents data loss and lags
    by resending the packet when necessary.

    The OpCode is 8 bits / 2 bytes, but is divided in 2 parts of 4 bits / 
    1 byte.









  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 19] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


    The first part describes the function of the packet :

  +==================================+==================================+
  |  0                               |  NOT_USED                        |
  |----------------------------------|----------------------------------|
  |  1 (from client)                 |  Input snapshot                  |
  |----------------------------------|----------------------------------|
  |  2 (from server)                 |  Array of GameElement and Player |
  |----------------------------------|----------------------------------|
  |  3 (from server)                 |  Array of destroyed GameElement  |
  |                                  |  and Player (only ID)            |
  |----------------------------------|----------------------------------|
  |  4 (from server)                 |  Game state (END/PAUSE)          |
  +==================================+==================================+

    The second part is used for acknowledgement and replies.

  +==================================+==================================+
  |  0                               |  NOT_USED                        |
  |----------------------------------|----------------------------------|
  |  1                               |  ACK NEED                        |
  |----------------------------------|----------------------------------|
  |  2                               |  ACK DONE                        |
  |----------------------------------|----------------------------------|
  |  3                               |                                  |
  +==================================+==================================+

  If a client/server receives a packet marked with ACK NEED, he MUST sent it
  back once without the data to inform it the packet was treated.
  This allows the client/server to reduce the snapshots size.


  The R-Type will use a snapshot system with a refresh rate (probably 15ms).
  The Timer depends on this refresh rate because the Timer represents the
  elapsed intervals from the start of the game.

  Input snapshots need to be sent every 100ms (or less).
  Server snapshots about the game need to be sent every 150ms

  With this technique, we can synchronize clients around 100ms and prevent
  packet loss impact on our game.

  This is inspired of source multiplayer networking
  https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking


  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 20] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


  5̲.̲3̲ ̲-̲ ̲D̲a̲t̲a̲ ̲f̲o̲r̲m̲a̲t̲

    The game client sends many packets when he's doing an action on the map,
    this action is done by the player when he press a / some key(s).
    

    The input data from client is defined like this:

  +======+===============+===============+===============+===============+
  | Byte |       1       |       2       |       3       |       4       |
  |------|---------------|---------------|---------------|---------------|
  | Bit  |   0  ...  7   |   8  ...  15  |  16  ...  23  |  24  ...  31  |
  |------|---------------+---------------|---------------+---------------|
  |      |        Input snapshot         |    Previous snapshots [1]     |
  |      |-------------------------------+-------------------------------|
  |      |                    Previous Snapshots [2]                     |
  +======+===============================================================+


    The "Input snapshot" defines the current state of the client, defined by
    the key(s) he pressed.
    This element MUST be filled.


    The "Previous snapshot [1]" defines the previous states of the client if
    it has not been validated by the server.
    This element CAN be filled.

    The "Previous snapshot [2]" defines the previous states of the client if
    it has not been validated by the server, with a maximum of 10.
    This element CAN be filled. 















  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 21] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


  The game clients receive many packets sent by the server, these packets
  are sent by the server right after there is a modification on the map,
  when it refreshes the game.
  In this case the content on the map is sent.
  

  The packets are defined with this structure :

  +======+===============+===============+===============+===============+
  | Byte |       1       |       2       |       3       |       4       |
  |------|---------------|---------------|---------------|---------------|
  | Bit  |   0  ...  7   |   8  ...  15  |  16  ...  23  |  24  ...  31  |
  |------|---------------+---------------+---------------+---------------|
  |      |                      Array of PlayerGame                      |
  |      |---------------------------------------------------------------|
  |      |                      Array of GameElement                     |
  +======+===============================================================+


  ALL the data in the packet MUST be filled.


  The "Array of PlayerGame" defines an array of "PlayerGame", each
  "PlayerGame" takes 64 bits / 8 bytes. A "PlayerGame" contains data
  for one player.

  The "Array of GameElement" defines an array of "GameElement", each
  "GameElement" takes 64 bits / 8 bytes. A "GameElement" contains data
  for one element of the map (enemy, rocket, ...) 





















  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 22] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


  The game clients receive many packets sent by the server, these packets
  are sent by the server right after there is a modification on the map,
  when it refreshes the game.
  In this case the characteristics of a player is sent.

  The packet is defined with this structure :

  +======+===============+===============+===============+===============+
  | Byte |       1       |       2       |       3       |       4       |
  |------|---------------|---------------|---------------|-----------+---|
  | Bit  |   0  ...  7   |   8  ...  15  |  16  ...  23  | 24 ... 30 | 31|
  |------|---------------+---------------|---------------+-----------|---|
  |      |              ID               |           Lives           |Al.|
  |      |-------------------------------+---------------------------+---|
  |      |                             Score                             |
  +======+===============================================================+


  ALL the data in the packet MUST be filled.


  The "ID" represents the ID of the concerned player, this id MUST be unique
  so there will have no conflict. This id is to identificate which player
  have which characterisitcs. This value MUST be filled in an unsigned short.

  The "Lives" defines how many lives the player has. The player lose a live
  every time he receive a shot. If has only 1 live left and receive a shot
  his number of lives will be 0 and his status alive will be set to 0, so
  this player is "dead". This value MUST be stored on 7 bits.

  The "Al." defines the state of the player, if he is alive. This value
  MUST be stored in an unsigned char.
  0 defines he is dead, 1 defines he is alive.

  The "Score" is the score of the player, in points. If at the end of the
  game the player is still alive, this score WILL be displayed on the
  client game. This value MUST be filled in an unsigned int.








  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 23] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/


  The game clients receive many packets sent by the server, these packets
  are sent by the server right after there is a modification on the map,
  when it refreshes the game.
  In this case the properties of a player / enemy on the map is sent.

  The packet is defined with this structure :

  +======+===============+===============+===============+===============+
  | Byte |       1       |       2       |       3       |       4       |
  |------|---------------|---------------|---------------|---------------|
  | Bit  |   0  ...  7   |   8  ...  15  |  16  ...  23  |  24  ...  31  |
  |------|---------------+---------------+---------------+---------------|
  |      |                              ID                               |
  |      |---------------------------------------------------------------|
  |      |                             Timer                             |
  |      |-------------------------------+-------------------------------|
  |      |               X               |               Y               |
  |      |-------------------------------+-------------------------------|
  |      |                             Angle                             |
  |      |---------------+-----------------------------------------------|
  |      |     Speed     |             Additional properties             |
  +======+===============+===============================================+


  ALL the data in the packet MUST be filled.


  The "ID" represents the id of the player / enemy. This id MUST be unique,
  so there will have no conflict, a conflict can occur if two elements have
  the same id, that's why it must be unique, to be able to differentiate
  them. This value MUST be filled in an unsigned int.

  The "Timer" is the timer of the player / enemy. It defines an interval
  that MUST be stored in an unsigned int.


  The "X" defines the x coordinate on the map, where the player / enemy
  is positioned on the card. X MUST be an unsigned short and filled like
  so : 100.

  The "Y" defines the y coordinate on the map, where the player / enemy
  is positioned on the card. Y MUST be an unsigned short and filled like
  so : 20.

  The "Angle" is the angle in degrees, it defines where the player / enemy
  is looking and to where his shots are going. The angle MUST be a float

  The "Speed" defines the player / enemy speed, more this value is high,
  more the speed of the movement will be high. The speed MUST be filled
  in an unsigned char.

  The "Additional properties" are additional properties that define the
  player / enemy. This data MUST be stored in 3 bytes.



  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 24] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/
 




















































  ___________________________________________________________________________
 /                                                                           \
|   Standards                                                       [Page 25] |
|                                   ~R-Type~                                  |
|   RFC 1                                                       November 2016 |
 \___________________________________________________________________________/
